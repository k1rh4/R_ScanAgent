from __future__ import annotations

import re
import stat
from datetime import datetime
from pathlib import Path
from typing import Any, Dict, List

from .candidates import Candidate
from .http_parser import parse_burp_json
from .probing import build_python_exploit


class OutputWriter:
    def __init__(self, base_dir: str = "output"):
        self.base_dir = Path(base_dir)

    def _safe_segment(self, value: str) -> str:
        cleaned = re.sub(r"[^a-zA-Z0-9._-]", "_", value.strip())
        return cleaned or "_"

    def _path_dir(self, path: str) -> Path:
        parts = [self._safe_segment(p) for p in path.strip("/").split("/") if p.strip()]
        if not parts:
            parts = ["__root__"]
        out = self.base_dir
        for part in parts:
            out = out / part
        return out

    def _chmod_exec(self, path: Path) -> None:
        try:
            mode = path.stat().st_mode
            path.chmod(mode | stat.S_IXUSR | stat.S_IXGRP | stat.S_IXOTH)
        except Exception:
            # Non-fatal on restricted filesystems.
            pass

    def _shell_quote(self, value: str) -> str:
        return "'" + value.replace("'", "'\"'\"'") + "'"

    def _build_sqlmap_script(self, raw_request: str, param: str) -> str:
        quoted_param = self._shell_quote(param)
        heredoc = "__REDSCAN_RAW_REQUEST__"
        return "\n".join(
            [
                "#!/usr/bin/env bash",
                "set -euo pipefail",
                "",
                "# Auto-generated by RedScan. Run to verify SQL injection.",
                'tmp_req="$(mktemp)"',
                'trap \'rm -f "$tmp_req"\' EXIT',
                f"cat > \"$tmp_req\" <<'{heredoc}'",
                raw_request.rstrip("\n"),
                heredoc,
                "",
                f"sqlmap -r \"$tmp_req\" -p {quoted_param} --batch --flush-session --random-agent",
                "",
            ]
        )

    def _build_python_script(self, payload_script: str) -> str:
        body = payload_script.strip()
        if not body.startswith("#!"):
            body = "#!/usr/bin/env python3\n" + body
        return body + "\n"

    def write(self, data: dict, path: str, phase: str, result: Dict[str, Any]) -> List[str]:
        findings = result.get("findings", []) if isinstance(result, dict) else []
        verified = [f for f in findings if f.get("analysis_status") == "VERIFIED"]
        if not verified:
            return []

        req, _ = parse_burp_json(data)
        out_dir = self._path_dir(path)
        out_dir.mkdir(parents=True, exist_ok=True)

        artifacts: List[str] = []
        timestamp = datetime.now().isoformat(timespec="seconds")

        md_lines = [
            f"# RedScan Report: {path}",
            "",
            f"- generated_at: {timestamp}",
            f"- phase: {phase}",
            f"- verified_count: {len(verified)}",
            "",
        ]

        for i, finding in enumerate(verified, start=1):
            vtype = finding.get("type", "")
            vector = finding.get("vector", "")
            reason = finding.get("reasoning", "")
            evidence = finding.get("verification_evidence", "")
            action = finding.get("action", {}) or {}
            tool = action.get("tool", "")
            payload = action.get("payload", "")

            md_lines.extend(
                [
                    f"## [{i}] {vtype}",
                    f"- vector: {vector}",
                    f"- tool: {tool}",
                    f"- reason: {reason}",
                    f"- evidence: {evidence}",
                    "",
                ]
            )

            script_path: Path | None = None
            script_body = ""
            if vtype == "SQL Injection":
                param = vector.split("/", 1)[0]
                script_path = out_dir / f"exploit_{i}_sqli.sh"
                script_body = self._build_sqlmap_script(req.raw, param)
                script_path.write_text(script_body, encoding="utf-8")
                self._chmod_exec(script_path)
                artifacts.append(script_path.as_posix())
            elif tool == "python_script" and isinstance(payload, str) and payload.strip():
                # Final phase payload already contains executable python script.
                if "requests.request(" in payload:
                    script_body = payload
                # Deep phase payload may be a raw string payload; build runnable script.
                else:
                    try:
                        param, location = vector.split("/", 1)
                        candidate = Candidate(vtype, location, param, reason)
                        script_body = build_python_exploit(req, candidate, payload)
                    except Exception:
                        script_body = ""

            if script_body and script_path is None:
                script_path = out_dir / f"exploit_{i}.py"
                script_path.write_text(self._build_python_script(script_body), encoding="utf-8")
                self._chmod_exec(script_path)
                artifacts.append(script_path.as_posix())

            if script_path and script_body:
                lang = "bash" if script_path.suffix == ".sh" else "python"
                md_lines.extend(
                    [
                        f"### Exploit Code (`{script_path.name}`)",
                        "",
                        f"```{lang}",
                        script_body.rstrip(),
                        "```",
                        "",
                    ]
                )
            elif script_path:
                md_lines.extend(
                    [
                        f"### Exploit Code (`{script_path.name}`)",
                        "",
                        "_코드 생성을 완료했지만 본문 임베딩은 생략되었습니다._",
                        "",
                    ]
                )

        report_md_path = out_dir / "report.md"
        report_md_path.write_text("\n".join(md_lines), encoding="utf-8")
        artifacts.append(report_md_path.as_posix())
        return artifacts
