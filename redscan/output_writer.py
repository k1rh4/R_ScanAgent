from __future__ import annotations

import json
import re
import stat
import tempfile
from datetime import datetime
from pathlib import Path
from urllib.parse import urlparse
from typing import Any, Dict, List

from .candidates import Candidate
from .http_parser import parse_burp_json
from .probing import build_python_exploit


class OutputWriter:
    def __init__(self, base_dir: str = "output"):
        self.base_dir = Path(base_dir)

    def _safe_segment(self, value: str) -> str:
        cleaned = re.sub(r"[^a-zA-Z0-9._-]", "_", value.strip())
        if cleaned in {".", ".."}:
            return "_"
        return cleaned or "_"

    def _safe_label(self, value: str, fallback: str) -> str:
        cleaned = self._safe_segment(value).strip("._-")
        return cleaned.lower() or fallback

    def _next_exploit_index(self) -> int:
        max_idx = 0
        for path in self.base_dir.glob("exploit_*"):
            match = re.match(r"^exploit_(\d+)", path.name)
            if not match:
                continue
            max_idx = max(max_idx, int(match.group(1)))
        return max_idx + 1

    def _chmod_exec(self, path: Path) -> None:
        try:
            mode = path.stat().st_mode
            path.chmod(mode | stat.S_IXUSR | stat.S_IXGRP | stat.S_IXOTH)
        except Exception:
            # Non-fatal on restricted filesystems.
            pass

    def _shell_quote(self, value: str) -> str:
        return "'" + value.replace("'", "'\"'\"'") + "'"

    def _atomic_write_text(self, path: Path, content: str) -> None:
        path.parent.mkdir(parents=True, exist_ok=True)
        tmp_path: str | None = None
        try:
            with tempfile.NamedTemporaryFile(
                "w",
                encoding="utf-8",
                dir=path.parent,
                prefix=f".{path.name}.",
                suffix=".tmp",
                delete=False,
            ) as tmp:
                tmp.write(content)
                tmp_path = tmp.name
            Path(tmp_path).replace(path)
        finally:
            if tmp_path and Path(tmp_path).exists():
                try:
                    Path(tmp_path).unlink()
                except Exception:
                    pass

    def _atomic_write_executable_text(self, path: Path, content: str) -> None:
        self._atomic_write_text(path, content)
        self._chmod_exec(path)

    def _build_sqlmap_script(self, raw_request: str, param: str) -> str:
        quoted_param = self._shell_quote(param)
        heredoc = "__REDSCAN_RAW_REQUEST__"
        return "\n".join(
            [
                "#!/usr/bin/env bash",
                "set -euo pipefail",
                "",
                "# Auto-generated by RedScan. Run to verify SQL injection.",
                'tmp_req="$(mktemp)"',
                'trap \'rm -f "$tmp_req"\' EXIT',
                f"cat > \"$tmp_req\" <<'{heredoc}'",
                raw_request.rstrip("\n"),
                heredoc,
                "",
                f"sqlmap -r \"$tmp_req\" -p {quoted_param} --batch --flush-session --random-agent",
                "",
            ]
        )

    def _build_python_script(self, payload_script: str) -> str:
        body = payload_script.strip()
        if not body.startswith("#!"):
            body = "#!/usr/bin/env python3\n" + body
        return body + "\n"

    def _evidence_json(self, evidence: str) -> Dict[str, Any] | None:
        if not evidence:
            return None
        text = evidence.strip()
        if not text.startswith("{"):
            return None
        try:
            data = json.loads(text)
            return data if isinstance(data, dict) else None
        except Exception:
            return None

    def _idor_summary(self, evidence: str) -> str:
        data = self._evidence_json(evidence)
        if data:
            parts = []
            status_base = data.get("status_base")
            status_probe = data.get("status_probe")
            if status_base is not None or status_probe is not None:
                parts.append(f"{status_base}->{status_probe}")
            if "similarity" in data:
                parts.append(f"sim={data.get('similarity')}")
            if "len_ratio" in data:
                parts.append(f"len_ratio={data.get('len_ratio')}")
            if "auth_hint" in data:
                parts.append(f"auth={data.get('auth_hint')}")
            return " ".join(parts)

        def _pick(pattern: str, default: str = "") -> str:
            m = re.search(pattern, evidence)
            return m.group(1) if m else default

        status_base = _pick(r"status_base=(\d+)")
        status_probe = _pick(r"status_probe=(\d+)")
        similarity = _pick(r"similarity=([0-9.]+)")
        len_ratio = _pick(r"len_ratio=([0-9.]+)")
        auth_hint = _pick(r"auth_hint=([a-z_]+)")
        parts = []
        if status_base or status_probe:
            parts.append(f"{status_base}->{status_probe}")
        if similarity:
            parts.append(f"sim={similarity}")
        if len_ratio:
            parts.append(f"len_ratio={len_ratio}")
        if auth_hint:
            parts.append(f"auth={auth_hint}")
        return " ".join(parts)

    def _path_hint(self, evidence: str) -> str:
        data = self._evidence_json(evidence)
        if data and "path" in data:
            return str(data.get("path") or "")
        m = re.search(r"path_hint=([^\\s]+)", evidence)
        return m.group(1) if m else ""

    def _vector_parts(self, vector: str) -> tuple[str, str]:
        if "/" not in vector:
            return vector or "-", "-"
        param, location = vector.split("/", 1)
        return (param or "-"), (location or "-")

    def _location_label(self, location: str) -> str:
        mapping = {
            "query": "query parameter",
            "body": "body parameter",
            "cookie": "cookie",
            "header": "header",
            "path": "path",
        }
        return mapping.get(location, location or "-")

    def _payload_preview(self, payload: Any, limit: int = 180) -> str:
        text = str(payload or "").strip()
        if not text:
            return "(empty)"
        one_line = " ".join(text.split())
        if len(one_line) > limit:
            return one_line[: limit - 3] + "..."
        return one_line

    def write(self, data: dict, path: str, phase: str, result: Dict[str, Any]) -> List[str]:
        findings = result.get("findings", []) if isinstance(result, dict) else []
        verified = [f for f in findings if f.get("analysis_status") == "VERIFIED"]
        if not verified:
            return []

        req, _ = parse_burp_json(data)
        self.base_dir.mkdir(parents=True, exist_ok=True)

        artifacts: List[str] = []
        timestamp = datetime.now().isoformat(timespec="seconds")
        report_md_path = self.base_dir / "report.md"
        exploit_index = self._next_exploit_index()

        parsed_url = urlparse(req.url)
        host = parsed_url.netloc or "unknown"
        full_url = req.url or ""
        section_lines = [
            f"## 스캔 대상: `{path}`",
            "",
            f"- 호스트: {host}",
            f"- URL: {full_url}",
            f"- 생성 시각: {timestamp}",
            f"- 분석 단계: {phase}",
            f"- 검증된 취약점 수: {len(verified)}",
            "",
        ]

        for i, finding in enumerate(verified, start=1):
            vtype = finding.get("type", "")
            vector = finding.get("vector", "")
            reason = finding.get("reasoning", "")
            evidence = finding.get("verification_evidence", "")
            action = finding.get("action", {}) or {}
            tool = action.get("tool", "")
            payload = action.get("payload", "")
            param, location = self._vector_parts(vector)
            attack_payload = finding.get("attack_payload", payload)
            location_label = self._location_label(location)
            param_label = "URL path" if location == "path" else param

            section_lines.extend(
                [
                    f"### [{i}] {vtype}",
                    f"- 벡터: {vector}",
                    f"- 확인 도구: {tool}",
                    f"- 공격 위치: {location_label}",
                    f"- 공격 파라미터: {param_label}",
                    f"- 주입/변경 값: `{self._payload_preview(attack_payload)}`",
                    f"- 취약점 판단 이유: {reason}",
                    *([f"- 경로: {self._path_hint(evidence)}"] if vector.endswith("/path") and self._path_hint(evidence) else []),
                    *([f"- IDOR 요약: {self._idor_summary(evidence)}"] if vtype == "IDOR" else []),
                    f"- 검증 근거: {evidence}",
                    "",
                ]
            )

            script_path: Path | None = None
            script_body = ""
            vuln_label = self._safe_label(vtype, "vuln")
            if vtype == "SQL Injection":
                param = vector.split("/", 1)[0]
                script_path = self.base_dir / f"exploit_{exploit_index}_{vuln_label}.sh"
                script_body = self._build_sqlmap_script(req.raw, param)
                self._atomic_write_executable_text(script_path, script_body)
                artifacts.append(script_path.as_posix())
                exploit_index += 1
            elif tool == "python_script" and isinstance(payload, str) and payload.strip():
                # Final phase payload already contains executable python script.
                if "requests.request(" in payload:
                    script_body = payload
                # Deep phase payload may be a raw string payload; build runnable script.
                else:
                    try:
                        param, location = vector.split("/", 1)
                        candidate = Candidate(vtype, location, param, reason)
                        script_body = build_python_exploit(req, candidate, payload)
                    except Exception:
                        script_body = ""

            if script_body and script_path is None:
                script_path = self.base_dir / f"exploit_{exploit_index}_{vuln_label}.py"
                self._atomic_write_executable_text(script_path, self._build_python_script(script_body))
                artifacts.append(script_path.as_posix())
                exploit_index += 1

            if script_path and script_body:
                section_lines.extend(
                    [
                        f"- exploit 파일: `{script_path.name}`",
                        "",
                    ]
                )
            elif script_path:
                section_lines.extend(
                    [
                        f"- exploit 파일: `{script_path.name}`",
                        "- 비고: 코드 생성은 완료됐지만 본문 표시는 생략됨",
                        "",
                    ]
                )
            else:
                section_lines.extend(
                    [
                        "- exploit 파일: 생성 실패",
                        "- 비고: action payload를 실행 가능한 코드로 변환하지 못함",
                        "",
                    ]
                )

        if report_md_path.exists():
            existing = report_md_path.read_text(encoding="utf-8").rstrip()
            report_body = existing + "\n\n---\n\n" + "\n".join(section_lines)
        else:
            header = [
                "# RedScan 취약점 리포트",
                "",
                "- 설명: 검증된 취약점과 판단 근거, 재현용 exploit 파일명을 기록합니다.",
                "",
            ]
            report_body = "\n".join(header + section_lines)
        self._atomic_write_text(report_md_path, report_body + "\n")
        artifacts.append(report_md_path.as_posix())
        return artifacts
